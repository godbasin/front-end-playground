<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>11.Ivy编译器之CLI编译器 | 被删的前端游乐场</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/front-end-playground/assets/css/0.styles.0d5b01aa.css" as="style"><link rel="preload" href="/front-end-playground/assets/js/app.fedc3436.js" as="script"><link rel="preload" href="/front-end-playground/assets/js/2.775d56f2.js" as="script"><link rel="preload" href="/front-end-playground/assets/js/3.c15c8d98.js" as="script"><link rel="preload" href="/front-end-playground/assets/js/30.8bbc02b2.js" as="script">
    <link rel="stylesheet" href="/front-end-playground/assets/css/0.styles.0d5b01aa.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/front-end-playground/" class="home-link router-link-active"><!----> <span class="site-name">被删的前端游乐场</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/front-end-playground/" class="nav-link">概述</a></div><div class="nav-item"><a href="/front-end-playground/front-end-basic/" class="nav-link">前端领域</a></div><div class="nav-item"><a href="/front-end-playground/vue/" class="nav-link">Vue学习</a></div><div class="nav-item"><a href="/front-end-playground/wxapp/" class="nav-link">小程序学习</a></div><div class="nav-item"><a href="/front-end-playground/angular/" class="nav-link router-link-active">Angular学习</a></div><div class="nav-item"><a href="/front-end-playground/front-end-others/" class="nav-link">百家齐放</a></div><div class="nav-item"><a href="/front-end-playground/front-end-addon/" class="nav-link">前端的进击</a></div><div class="nav-item"><a href="/front-end-playground/front-end-work/" class="nav-link">前端与工作</a></div><div class="nav-item"><a href="/front-end-playground/faq.html" class="nav-link">FAQ</a></div> <a href="https://github.com/godbasin/front-end-playground" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/front-end-playground/" class="nav-link">概述</a></div><div class="nav-item"><a href="/front-end-playground/front-end-basic/" class="nav-link">前端领域</a></div><div class="nav-item"><a href="/front-end-playground/vue/" class="nav-link">Vue学习</a></div><div class="nav-item"><a href="/front-end-playground/wxapp/" class="nav-link">小程序学习</a></div><div class="nav-item"><a href="/front-end-playground/angular/" class="nav-link router-link-active">Angular学习</a></div><div class="nav-item"><a href="/front-end-playground/front-end-others/" class="nav-link">百家齐放</a></div><div class="nav-item"><a href="/front-end-playground/front-end-addon/" class="nav-link">前端的进击</a></div><div class="nav-item"><a href="/front-end-playground/front-end-work/" class="nav-link">前端与工作</a></div><div class="nav-item"><a href="/front-end-playground/faq.html" class="nav-link">FAQ</a></div> <a href="https://github.com/godbasin/front-end-playground" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0" style="padding-top:10px;"><div class="kitty-main" data-v-2b653b36><span class="stand" data-v-2b653b36></span> <div class="cat" data-v-2b653b36><div class="body" data-v-2b653b36></div> <div class="head" data-v-2b653b36><div class="ear" data-v-2b653b36></div> <div class="ear" data-v-2b653b36></div></div> <div class="face" data-v-2b653b36><div class="nose" data-v-2b653b36></div> <div class="whisker-container" data-v-2b653b36><div class="whisker" data-v-2b653b36></div> <div class="whisker" data-v-2b653b36></div></div> <div class="whisker-container" data-v-2b653b36><div class="whisker" data-v-2b653b36></div> <div class="whisker" data-v-2b653b36></div></div></div> <div class="tail-container" data-v-2b653b36><div class="tail" data-v-2b653b36><div class="tail" data-v-2b653b36><div class="tail" data-v-2b653b36><div class="tail" data-v-2b653b36><div class="tail" data-v-2b653b36><div class="tail" data-v-2b653b36><div class="tail" data-v-2b653b36></div></div></div></div></div></div></div></div></div></div> <p class="sidebar-heading open"><span>Angular框架解读</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/front-end-playground/angular/deep-into-angular/angular-design-0-prestart.html" class="sidebar-link">0.预热篇</a></li><li><a href="/front-end-playground/angular/deep-into-angular/angular-design-metadata.html" class="sidebar-link">1.元数据和装饰器</a></li><li><a href="/front-end-playground/angular/deep-into-angular/angular-design-dom-define.html" class="sidebar-link">2.视图抽象定义</a></li><li><a href="/front-end-playground/angular/deep-into-angular/angular-design-zonejs.html" class="sidebar-link">3.Zone区域之zone.js</a></li><li><a href="/front-end-playground/angular/deep-into-angular/angular-design-zone-ngzone.html" class="sidebar-link">4.Zone区域之ngZone</a></li><li><a href="/front-end-playground/angular/deep-into-angular/angular-design-module.html" class="sidebar-link">5.模块化组织</a></li><li><a href="/front-end-playground/angular/deep-into-angular/angular-design-di-1-basic-concepts.html" class="sidebar-link">6.依赖注入的基本概念</a></li><li><a href="/front-end-playground/angular/deep-into-angular/angular-design-di-2-hierarchical-di.html" class="sidebar-link">7.多级依赖注入设计</a></li><li><a href="/front-end-playground/angular/deep-into-angular/angular-design-di-3-bootstrap.html" class="sidebar-link">8.依赖注入的引导过程</a></li><li><a href="/front-end-playground/angular/deep-into-angular/angular-design-ivy-0-design.html" class="sidebar-link">9.Ivy编译器整体设计</a></li><li><a href="/front-end-playground/angular/deep-into-angular/angular-design-ivy-1-view-data-and-node-injector.html" class="sidebar-link">10.Ivy编译器的视图数据和依赖解析</a></li><li><a href="/front-end-playground/angular/deep-into-angular/angular-design-ivy-2-cli-compiler.html" aria-current="page" class="active sidebar-link">11.Ivy编译器之CLI编译器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-playground/angular/deep-into-angular/angular-design-ivy-2-cli-compiler.html#ivy-编译器" class="sidebar-link">Ivy 编译器</a></li><li class="sidebar-sub-header"><a href="/front-end-playground/angular/deep-into-angular/angular-design-ivy-2-cli-compiler.html#ngtsc-编译器" class="sidebar-link">ngtsc 编译器</a></li><li class="sidebar-sub-header"><a href="/front-end-playground/angular/deep-into-angular/angular-design-ivy-2-cli-compiler.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/front-end-playground/angular/deep-into-angular/angular-design-ivy-3-mental-model.html" class="sidebar-link">12.Ivy编译器之心智模型</a></li><li><a href="/front-end-playground/angular/deep-into-angular/angular-design-ivy-4-aot-jit.html" class="sidebar-link">13.Ivy编译器之AOT/JIT</a></li><li><a href="/front-end-playground/angular/deep-into-angular/angular-design-ivy-5-incremental-dom.html" class="sidebar-link">14.Ivy编译器之增量DOM</a></li><li><a href="/front-end-playground/angular/deep-into-angular/angular-design-ivy-6-detect-change.html" class="sidebar-link">15.Ivy编译器之变更检测</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0" style="padding-top:;"><!----> <p class="sidebar-heading"><span>玩转 Angular</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>作为“为大型前端项目”而设计的前端框架，Angular 其实有许多值得参考和学习的设计，本系列主要用于研究这些设计和功能的实现原理。本文围绕 Angular 的核心功能 Ivy 编译器，介绍其中CLI层面的编译器编译过程。</p> <p>在 Angular 中实现了自己的编译器，来处理 TypeScript 编译器无法完全做到的一些事情。在 Ivy 编译器中，这部分的能力又做了进一步的提升，比如模板类型检查、模块依赖解析等等。</p> <h2 id="ivy-编译器"><a href="#ivy-编译器" class="header-anchor">#</a> Ivy 编译器</h2> <p>在前面<a href="/front-end-playground/angular/deep-into-angular/angular-design-ivy-0-design.html">9.Ivy 编译器整体设计</a>一文中，我有介绍 Ivy 编译器主要包括两部分：</p> <ol><li><code>ngtsc</code>：作为主要的 Ivy 编译器，将 Angular 装饰器化为静态属性。</li> <li><code>ngcc</code>：作为兼容性的 Ivy 编译器，主要负责处理来自 NPM 的代码并生成等效的 Ivy 版本。</li></ol> <p>本文将会主要围绕<code>ngtsc</code>该编译器进行介绍。</p> <h3 id="angular-中的-ast-解析"><a href="#angular-中的-ast-解析" class="header-anchor">#</a> Angular 中的 AST 解析</h3> <p>要实现 AST 的解析和转换，离不开解析器。对于 Typescript 代码来说，编译器的整体流程为：</p> <div class="language- extra-class"><pre class="language-text"><code>                                                                |------------|
                           |----------------------------------&gt; | TypeScript |
                           |                                    |   .d.ts    |
                           |                                    |------------|
                           |
|------------|          |-----|               |-----|           |------------|
| TypeScript | -parse-&gt; | AST | -&gt;transform-&gt; | AST | -&gt;print-&gt; | JavaScript |
|   source   |    |     |-----|       |       |-----|           |   source   |
|------------|    |        |          |                         |------------|
                  |    type-check     |
                  |        |          |
                  |        v          |
                  |    |--------|     |
                  |--&gt; | errors | &lt;---|
                       |--------|
</code></pre></div><p>该过程包括四个步骤：</p> <ol><li>parse 解析：它是一个传统的递归下降解析器，稍微调整以支持增量解析，它发出一个抽象语法树 (AST)，有助于识别文件中导入了哪些文件。</li> <li>type-check 类型检查器：类型检查器构建一个符号表，然后对文件中的每个表达式进行类型分析，报告它发现的错误。</li> <li>transform 转换：转换步骤是一组 AST 到 AST 转换，它们执行各种任务，例如删除类型声明、将模块和类声明降低到 ES5、将异步方法转换为状态机等。</li> <li>print 打印：TS 到 JS 的实际转换是整个过程中最昂贵的操作。</li></ol> <p>在了解 Angular 是如何处理之前，我们需要知道，对 TypeScript 编译器 API 的任何使用都遵循一个多步骤过程，包括：</p> <p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/angular-design-ivy-2-ast-1.jpg" alt=""></p> <ul><li>一个<code>ts.CompilerHost</code>被创建</li> <li><code>ts.CompilerHost</code>加上一组“根文件”，用于创建<code>ts.Program</code>,<code>ts.Program</code>用于收集各种诊断（类型检查）</li> <li><code>ts.Program</code>被要求<code>emit</code>，并生成 JavaScript 代码</li></ul> <p>将 Angular 编译集成到此过程中的编译器遵循非常相似的流程，但有一些额外的步骤：</p> <ul><li>一个<code>ts.CompilerHost</code>被创建</li> <li><code>ts.CompilerHost</code>包含在<code>NgCompilerHost</code>中，它将 Angular 特定文件添加到编译中</li> <li><code>ts.Program</code>是从<code>NgCompilerHost</code>及其增强的根文件集创建的</li> <li>一个<code>CompilationTicket</code>被创建，可选择合并来自先前编译运行的任何状态</li> <li><code>NgCompiler</code>是使用<code>CompilationTicket</code>创建的</li> <li>诊断信息可以正常从<code>ts.Program</code>收集，也可以从<code>NgCompiler</code>收集</li> <li>在发射之前，调用<code>NgCompiler.prepareEmit</code>以检索需要馈送到<code>ts.Program.emit</code>的 Angular 转换器</li> <li>使用上面的 Angular 转换器在<code>ts.Program</code>上调用发射，它生成带有 Angular 扩展的 JavaScript 代码</li></ul> <p>在这些 Angular 特定的步骤中，主要进行几件事：</p> <p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/angular-design-ivy-2-ast-2.jpg" alt=""></p> <ol><li>会将特定于 Angular 的文件添加到编译过程中，比如<code>NgModele</code>、<code>Component</code>的解析。</li> <li>修改生成的<code>d.ts</code>，来保存 Angular 中模块和文件间的依赖关系。</li> <li>会增加 Angular 中的类型校验，包括<code>&lt;tmeplate&gt;</code>模板的类型校验。</li></ol> <p>而在自定义 TypeScript 编译器中执行 Angular 编译，主要依赖于<code>NgCompiler</code>，我们来看一下核心的一些方法：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">NgCompiler</span> <span class="token punctuation">{</span>
  <span class="token comment">// 将一个 CompilationTicket 转换为一个用于请求编译的 NgCompiler 实例</span>
  <span class="token comment">// 根据编译请求的性质，NgCompiler 实例可能会从以前的编译中重用并随着任何更改进行更新</span>
  <span class="token comment">// 它可能是一个新实例，它可以增量地重用以前编译中的状态，或者它可能代表一个完全新的编译 </span>
  <span class="token keyword">static</span> <span class="token function">fromTicket</span><span class="token punctuation">(</span>ticket<span class="token operator">:</span> CompilationTicket<span class="token punctuation">,</span> adapter<span class="token operator">:</span> NgCompilerAdapter<span class="token punctuation">,</span> perfRecorder<span class="token operator">?</span><span class="token operator">:</span> PerfRecorder<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// 获取文件的资源依赖</span>
  <span class="token function">getResourceDependencies</span><span class="token punctuation">(</span>file<span class="token operator">:</span> ts<span class="token punctuation">.</span>SourceFile<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// 获取此编译的所有与 Angular 相关的诊断信息</span>
  <span class="token function">getDiagnostics</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> ts<span class="token punctuation">.</span>Diagnostic<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// 将 Angular.io 错误指南链接添加到此编译的诊断中</span>
  <span class="token keyword">private</span> <span class="token function">addMessageTextDetails</span><span class="token punctuation">(</span>diagnostics<span class="token operator">:</span> ts<span class="token punctuation">.</span>Diagnostic<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> ts<span class="token punctuation">.</span>Diagnostic<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  <span class="token comment">// 获取 ts.Program 以用作生成后续增量编译的起点</span>
  <span class="token comment">// NgCompiler 产生一个内部增量 TypeScript 编译（为了模板类型检查的目的，将消费者的 `ts.Program` 继承到一个新的编译器中）</span>
  <span class="token comment">// 此操作后，消费者的 ts.Program 不再可用于启动新的增量编译，getNextProgram 检索可以替代使用的 ts.Program</span>
  <span class="token function">getNextProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> ts<span class="token punctuation">.</span>Program <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// 异步执行 Angular 的分析步骤</span>
  <span class="token comment">// 通常，每当调用 getDiagnostics 或 prepareEmit 时，都会延迟执行此操作</span>
  <span class="token comment">// 然而，某些消费者可能希望允许分析的异步阶段，其中诸如 “styleUrls” 之类的资源被异步解析</span>
  <span class="token comment">// 在这些情况下，必须首先调用 analyzeAsync，并且在调用 NgCompiler 的任何其他 API 之前等待它的 Promise</span>
  <span class="token keyword">async</span> <span class="token function">analyzeAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// 列出在分析过程中检测到的惰性路由</span>
  <span class="token function">listLazyRoutes</span><span class="token punctuation">(</span>entryRoute<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> LazyRoute<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可见，<code>NgCompiler</code>主要负责将 Angular 编译集成到 TypeScript 编译器的编译流程中，并支持了上述提到的错误信息诊断（类型检查）、依赖关系检索，其中的设计还支持了增量编译、异步编译等能力。</p> <h2 id="ngtsc-编译器"><a href="#ngtsc-编译器" class="header-anchor">#</a> ngtsc 编译器</h2> <p><code>ngtsc</code>是一个 Typescript-to-Javascript 编译器。它是一个最小包装器，包裹在<code>tsc</code>之外，而<code>tsc</code>中则包含一系列的 Angular 变换。</p> <h3 id="编译器流程"><a href="#编译器流程" class="header-anchor">#</a> 编译器流程</h3> <p>和<code>tsc</code>一样，当<code>ngtsc</code>开始运行时，它首先解析<code>tsconfig.json</code>文件，然后创建一个<code>ts.Program</code>。在上述转换可以运行之前，需要进行几件事情：</p> <ul><li>为包含修饰符的输入源文件收集元数据</li> <li><code>@Component</code>装饰器中列出的资源文件必须异步解析
<ul><li>例如 CLI 中，可能希望运行的 WebPack 以产生<code>.css</code>输入到<code>styleUrls</code>的属性<code>@Component</code></li></ul></li> <li>运行诊断程序，这会创建<code>TypeChecker</code>并触及程序中的每个节点（一个相当昂贵的操作）</li></ul> <p>因为资源加载是异步的（特别是可能通过子进程并发），所以最好在做任何昂贵的事情之前启动尽可能多的资源加载。</p> <p><code>ngtsc</code>的运行入口位于<code>NgtscProgram</code>中，可直接替代传统的 View Engine 编译器到诸如命令行<code>main()</code>函数或 Angular 之类的工具命令行界面。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">NgtscProgram</span> <span class="token keyword">implements</span> <span class="token class-name">api</span><span class="token punctuation">.</span>Program <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> compiler<span class="token operator">:</span> NgCompiler<span class="token punctuation">;</span>
  <span class="token comment">// 主要的 TypeScript 程序，用于分析和发出</span>
  <span class="token keyword">private</span> tsProgram<span class="token operator">:</span> ts<span class="token punctuation">.</span>Program<span class="token punctuation">;</span>

  <span class="token keyword">private</span> closureCompilerEnabled<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  <span class="token keyword">private</span> host<span class="token operator">:</span> NgCompilerHost<span class="token punctuation">;</span>
  <span class="token keyword">private</span> incrementalStrategy<span class="token operator">:</span> TrackedIncrementalBuildStrategy<span class="token punctuation">;</span>

  <span class="token comment">// 其他方法</span>
<span class="token punctuation">}</span>
</code></pre></div><p>编译器流程如下所示：</p> <ol><li>创建<code>ts.Program</code>。</li> <li>扫描源文件以查找具有微不足道的可检测<code>@Component</code>注释的顶级声明，这避免了创建<code>TypeChecker</code>。</li></ol> <ul><li>对于每个具有<code>templateUrlor</code>的此类声明<code>styleUrls</code>，启动该 URL 的资源加载并将加入<code>Promise</code>队列</li></ul> <ol start="3"><li>获取诊断信息并报告任何初始错误消息。此时，<code>TypeChecker</code>已准备就绪。</li> <li>对<code>@Component</code>注释进行彻底扫描，使用<code>TypeChecker</code>和元数据系统来解析任何复杂的表达式。</li> <li>等待所有资源得到解决。</li> <li>计算需要应用的一组变换。</li> <li>启动<code>Tsickle</code>发射，它运行变换。</li> <li>在<code>.d.ts</code>文件的发出回调期间，重新解析发出的<code>.d.ts</code>并合并来自<code>Angular</code>编译器的任何请求更改。</li></ol> <p>Angular 编译涉及将 Angular 装饰器转换为静态定义字段。在构建时，这是在 TypeScript 编译的整个过程中完成的，其中 TypeScript 代码经过类型检查，然后降级为 JavaScript 代码。在此过程中，还可以生成特定于 Angular 的诊断。</p> <h3 id="增量编译"><a href="#增量编译" class="header-anchor">#</a> 增量编译</h3> <p>前面我们介绍了 Ivy 编译器的一些特性，其中包括了通过增加增量编译，来缩短构建时间。</p> <p>作为在 TypeScript 编译器中执行 Angular 编译的核心 API，<code>NgCompiler</code>的每个实例都支持单个编译，因此也支持增量编译。</p> <p>Angular 编译器能够进行增量编译，其中来自先前编译的信息用于加速下一次编译。在编译期间，编译器产生两种主要信息：本地信息（如组件和指令元数据）和全局信息（如具体化的<code>NgModule</code>范围）。增量编译通过两种方式进行管理：</p> <ol><li>对于大多数更改，新的<code>NgCompiler</code>可以有选择地从以前的实例继承本地信息，并且只需要在底层 TypeScript 文件发生更改的地方重新计算它。在这种情况下，全局信息总是从头开始重新计算。</li> <li>对于特定的更改，例如组件资源中的更改，<code>NgCompiler</code>可以整体重用，并更新以合并此类更改的影响，而无需重新计算任何其他信息。</li></ol> <p>请注意，这两种模式在是否需要新<code>NgCompiler</code>实例或是否可以重用之前的实例方面有所不同。为了防止泄漏这种实现的复杂性并保护消费者不必管理<code>NgCompiler</code>如此具体的生命周期，这个过程通过<code>CompilationTicket</code>进行了抽象。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">CompilationTicket</span> <span class="token operator">=</span>
  <span class="token comment">// 从头开始 Angular 编译操作</span>
  FreshCompilationTicket <span class="token operator">|</span> 
  <span class="token comment">// 开始包含对 TypeScript 代码的更改的 Angular 编译操作</span>
  IncrementalTypeScriptCompilationTicket <span class="token operator">|</span> 
  IncrementalResourceCompilationTicket<span class="token punctuation">;</span>
</code></pre></div><p><code>CompilationTicket</code>用于初始化（或更新）<code>NgCompiler</code>实例，该实例为 Angular 编译器的核心。<code>CompilationTicket</code>抽象了编译的起始状态，并允许独立于任何增量编译生命周期管理<code>NgCompiler</code>。</p> <p>消费者首先获得一个<code>CompilationTicket</code>（取决于传入更改的性质），然后使用该票据获取<code>NgCompiler</code>实例。在创建<code>CompilationTicket</code>时，编译器可以决定是重用旧<code>NgCompiler</code>实例还是创建新实例。</p> <h3 id="异步编译"><a href="#异步编译" class="header-anchor">#</a> 异步编译</h3> <p>在某些编译环境（例如 Angular CLI 中的 Webpack 驱动编译）中，编译的各种输入只能以异步方式生成。例如，<code>styleUrls</code>链接到 SASS 文件的 SASS 编译需要产生一个子 Webpack 编译。为了支持这一点，Angular 有一个异步接口来加载这些资源。</p> <p>如果使用此接口，则<code>NgCompiler</code>创建后的另一个异步步骤是调用<code>NgCompiler.analyzeAsync</code>并等待其<code>Promise</code>：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">NgtscProgram</span> <span class="token keyword">implements</span> <span class="token class-name">api</span><span class="token punctuation">.</span>Program <span class="token punctuation">{</span>
   <span class="token operator">...</span>
  <span class="token comment">/**
    * 确保 NgCompiler 已正确分析程序，并允许在此过程中异步加载任何资源。
    * Angular CLI 使用它来允许为 styleUrls 中使用的 SASS 文件等内容生成（异步）子编译。
    */</span>
  <span class="token function">loadNgStructureAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>compiler<span class="token punctuation">.</span><span class="token function">analyzeAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>此操作完成后，所有资源均已加载，其余<code>NgCompilerAPI</code>可以同步使用。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>Angular 是一套大而全的解决方案，想必大家早已对此有所了解。但实际上 Angular 做了很多深度的设计和能力，包括给开发者更好的体验，比如模板类型检查中，是如何将这些 Angular 特定的类型检查能力添加到 TypeScript 编译过程中，并且能通过文件映射能准确反馈给用户具体的代码位置，这些都是作为开发者的我未曾考虑过的。</p> <p>感觉 Angular 里面还有特别多值得学习的东西。</p> <h3 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h3> <ul><li><a href="https://github.com/angular/angular/blob/master/packages/compiler/design/architecture.md" target="_blank" rel="noopener noreferrer">DESIGN DOC(Ivy): Compiler Architecture<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://indepth.dev/posts/1151/a-deep-dive-into-injectable-and-providedin-in-ivy" target="_blank" rel="noopener noreferrer">A Deep Dive into @Injectable and providedIn in Ivy<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://indepth.dev/posts/1062/ivy-engine-in-angular-first-in-depth-look-at-compilation-runtime-and-change-detection" target="_blank" rel="noopener noreferrer">Ivy engine in Angular: first in-depth look at compilation, runtime and change detection<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://indepth.dev/posts/1053/everything-you-need-to-know-about-change-detection-in-angular" target="_blank" rel="noopener noreferrer">Everything you need to know about change detection in Angular<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.youtube.com/watch?v=anphffaCZrQ" target="_blank" rel="noopener noreferrer">Deep Dive into the Angular Compiler | Alex Rickabaugh<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <!----> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/godbasin/front-end-playground/edit/sourcecode/docs/angular/deep-into-angular/angular-design-ivy-2-cli-compiler.md" target="_blank" rel="noopener noreferrer">帮阿猪改善此页面！</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <blockquote>部分文章中使用了一些网站的截图，如果涉及侵权，请告诉我删一下谢谢~</blockquote> <div style="margin-top:30px;"><div class="el-row" style="margin-left:-10px;margin-right:-10px;"><div class="el-col el-col-24 el-col-sm-0 el-col-md-2 el-col-lg-4" style="padding-left:10px;padding-right:10px;display:block;"><div style="width:1px;height:1px;"></div></div> <div class="el-col el-col-24 el-col-sm-24 el-col-md-18 el-col-lg-16" style="padding-left:10px;padding-right:10px;"><div class="el-card box-card is-always-shadow"><div class="el-card__header"><div class="clearfix"><span>温馨提示喵</span></div></div><div class="el-card__body"> <div class="el-row" style="margin-left:-10px;margin-right:-10px;"><div class="el-col el-col-24 el-col-xs-24 el-col-sm-12" style="padding-left:10px;padding-right:10px;"><div class="el-image"><div class="image-slot"><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/assets/img/loading.gif" style="width:100%;"></div><!----></div></div> <div class="el-col el-col-24 el-col-xs-24 el-col-sm-12" style="padding-left:10px;padding-right:10px;"><div class="copyright-text"><div>本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</div> <div>出处：被删的前端游乐场</div> <div>作者：<a href="https://github.com/godbasin" target="_blank">被删</a></div></div></div></div></div></div></div></div></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/front-end-playground/angular/deep-into-angular/angular-design-ivy-1-view-data-and-node-injector.html" class="prev">
          10.Ivy编译器的视图数据和依赖解析
        </a></span> <span class="next"><a href="/front-end-playground/angular/deep-into-angular/angular-design-ivy-3-mental-model.html">
          12.Ivy编译器之心智模型
        </a>
        →
      </span></p></div>  <div class="gitalk-container theme-default-content"><div id="gitalk-container" class="content"></div></div></main> <div id="kitty-container"><span><div role="tooltip" id="el-popover-461" aria-hidden="true" class="el-popover el-popper" style="width:undefinedpx;display:none;"><!----><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/2code2.jpg" class="image"> <div class="text">牡羊猪的猫粮罐</div> </div><span class="el-popover__reference-wrapper"><div id="kitty" style="background:url(https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/assets/img/kitty2.svg);"></div></span></span> <div class="el-dialog__wrapper" style="display:none;"><div role="dialog" aria-modal="true" aria-label="牡羊猪是这样渐渐胖成猪的喵（点击图片可以切换噢）" class="el-dialog" style="margin-top:15vh;"><div class="el-dialog__header"><span class="el-dialog__title">牡羊猪是这样渐渐胖成猪的喵（点击图片可以切换噢）</span><button type="button" aria-label="Close" class="el-dialog__headerbtn"><i class="el-dialog__close el-icon el-icon-close"></i></button></div><!----><!----></div></div></div></div><div class="global-ui"></div></div>
    <script src="/front-end-playground/assets/js/app.fedc3436.js" defer></script><script src="/front-end-playground/assets/js/2.775d56f2.js" defer></script><script src="/front-end-playground/assets/js/3.c15c8d98.js" defer></script><script src="/front-end-playground/assets/js/30.8bbc02b2.js" defer></script>
  </body>
</html>
